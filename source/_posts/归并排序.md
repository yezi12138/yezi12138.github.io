---
title: 归并排序
date: 2017-05-24 09:21:54
tags: -排序算法
---
# 归并排序

------

最近学了一个新的排序方法，分享给大家

## 原理：
利用递归原理，把一个数组逐渐分割成两个很小的单位，然后进行比较，返回比较后的数组，再往上递归回去。
**比如一个数组a[1,3,2,7,5]** 
1 第一次将数组分为left=[1,3],right=[2,7,5]
2 第二次递归将[1,3]分为[1],[3],这是已经是最小单位，然后进行比较1，3
创建一个新的数组result[]，将小的压进result，然后将left数组为空，进行下一步，把right的数值压进result，最后返回result
3 第三次递归将[2,7,5]分为[2,7],[5]
4 第四次递归将[2,7]分为[2],[7],然后重新比较，返回result
5 回到上一层，这是比较的是[2,7]和[5],因为2<5，将2压进result，再次比较7和5，jiang 5压进，这个时候right为空，进行下一步，把left剩余数值压进result，返回result=[2，5，7]
6 返回上一层，这时候比较的是left=[1,3],right=[2,5,7]，同理最后返回[1,2,3,5,7]，排序成功

<font color="red">不清楚的朋友可以自己按代码一步一步走下去感受一下步骤</font>

## 下面是我测试的代码

    <!DOCTYPE html>
    <html lang="en">
    <head>
    	<meta charset="UTF-8">
    	<title>sort</title>
    </head>
    <body>
    	
    </body>
    <script>
    	window.onload = function(){
    
    		//创建测试用的随机数组
    		var textArray = (function(){
    			var arr =new Array(10000).join(",").split(",");
    			//如果是arr =new Array(100),虽然长度为100，可是里面没有元素的
    			arr=arr.map(function(item){
    				return Math.floor(Math.random()*10000);
    			})
    			return arr;
    		})();
    		console.log(textArray);
    		var durantion1 = text1(textArray);
    		var durantion2 = text2(textArray);
    		console.log("归并排序:"+durantion1);
    		console.log("冒泡排序:"+durantion2);
    
    		//归并排序
    		function MergeSort (arr){
    			if(!(arr instanceof Array)){return;}
    			var len = arr.length;
    			if(len<2) return arr;
    			var middle = Math.floor(len/2),
    			left = arr.slice(0,middle),
    			right = arr.slice(middle);
    			return sort(MergeSort (left),MergeSort (right));
    			function sort(left,right){
    				var result = [];
    				while(left.length&&right.length){
    					if(left[0]<=right[0]){
    						result.push(left.shift());
    					}else{
    						result.push(right.shift());
    					}
    				}
    				while(left.length){
    					result.push(left.shift());
    				}
    				while(right.length){
    					result.push(right.shift());
    				}
    				return result;
    			}
    		}
    
    		//冒泡排序
    		function BubleSort(arr){
    			var len = arr.length;
    			for(var i=0;i<len;i++){
    				for(var j=0;j<len-1-i;j++){
    					if(arr[j]>arr[j+1]){
    						var temp = arr[j+1];
    						arr[j+1] = arr[j];
    						arr[j] = temp;
    					}
    				}
    			}
    			return arr;
    		}
    		
    		//测试算法时间
    		function text1(textArray){
    			var start = new Date().getTime();
    			MergeSort(textArray);
    			var end = new Date().getTime();//接受时间
    			return (end - start)+"ms";//返回函数执行需要时间
    		}
    		function text2(textArray){
    			var start = new Date().getTime();
    			BubleSort(textArray);
    			var end = new Date().getTime();//接受时间
    			return (end - start)+"ms";//返回函数执行需要时间
    		}
    	}
    </script>
    </html>



  这次测试我用冒泡排序来比较，在比较小的数组下，归并和冒泡几乎没什么差别，测试了下在1000空间下差别是大概7ms之间，到10000空间的时候，归并排序就比冒泡排序快10倍以上