---
title: H5上传图片
date: 2017-07-19 19:37:19
tags: -H5
---
# H5上传头像

------

大体的思路是，部分API的兼容性请参照caniuse：

1. 利用FileReader,读取blob对象,或者是file对象，将图片转化为data uri的形式。
2. 使用canvas,在页面上新建一个画布,利用canvas提供的API,将图片画入这个画布当中。
3. 利用canvas.toDataURL()，进行图片的压缩，得到图片的data uri的值
4. 上传文件


##  HTML部分 （在vue环境下执行）

    <input type="file" class="fileInput" ref='fileInput' accept="image/*">
 accept="image/*" 表示只接受图片类型的文件


## 监听input[type='file']选择文件

    this.$refs.fileInput.addEventListener('change', (event) => {
        console.log(this.$refs.fileInput.files[0])
        var file = this.$refs.fileInput.files[0]
        // 传入图像文件
        that.upLoadAvatar(file)
      })

## 显示图像函数

    upLoadAvatar (file) {
        var that = this
        var fr = new FileReader()
        fr.readAsDataURL(file)
        fr.onload = function (e) {
          that.$refs.img.setAttribute('src', e.target.result)
        }
      }
      
这样就可以在本地调试完毕，图像能够正确选择出来

---

## 利用canvas压缩图片大小
增加canvas标签，设置隐藏不可见

    <canvas id="canvas" style="display:none"></canvas>
增加压缩函数

    compressImg (img) {
        var canvas = document.getElementById('canvas')
        var ctx = canvas.getContext('2d')
        // 利用canvas进行绘图
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
        // 将原来图片的质量压缩到原先的0.2倍。
        var data = canvas.toDataURL('image/jpeg', 0.2) // data url的形式
        return data
      }
      
#### HTMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi

> canvas.toDataURL(type, encoderOptions)

<font color='red'>type 可选</font>
图片格式，默认为 image/png
<font color='red'>encoderOptions 可选</font>
在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。


#### 回到整题，修改uploadAvatar函数

    upLoadAvatar (file) {
        if (!file) {
          return
        }
        var MAXSIZE = 100 * 1024 // 超过这个值就进行压缩
        var that = this
        var fr = new FileReader()
        fr.onload = function (e) {
          var result = this.result
          var img = new Image()
          
          // img.onload必须的，不然加载的图片会看不见
          img.onload = function () {
            // 如果大于100K则进行压缩
            if (file.size >= MAXSIZE) {
              var imgData = that.compressImg(img)
              // username用来辨别用户，avatar是上传的图片
              let userInfo = {
                username: that.user.name,
                avatar: imgData
              }
              that.$http.post('/refreshInfo', {userInfo}).then((res) => {
                that.user = res.data
              })
            } else {
                // 不压缩则直接上传
              let userInfo = {
                username: that.user.name,
                avatar: result
              }
              that.$http.post('/refreshInfo', {userInfo}).then((res) => {
                that.user = res.data
              })
            }
          }
          img.src = this.result
        }
        fr.readAsDataURL(file)
      }
      
#### <font color='red'>注意：</font>
fr.onload = function () {
    this.result...   // 这个返回的是base64编码的url，可以直接发送
}


---

## 后台处理，返回修改后的数据
用node模拟了后台接口，实现对mongoose数据的修改和数据返回

    router.post('/refreshInfo', (req, res) => {
        var userInfo = req.body.userInfo
        // 不允许修改密码
        if (userInfo.password) {
            return
        }
        // 修改mongoose的数据
        user.update({username: userInfo.username}, {$set: {avatar: userInfo.avatar}}, function (err, result) {
          if (err) {
            console.log(err)
        } else {
            console.log('update success')
            user.find({username: userInfo.username}, (err, data) => {
                if (err) {
                    console.log(err)
                } else {
                    if (data.length === 0) {
                       res.send('fail')
                   } else {
                    var user = {
                        name: data[0].username,
                        avatar: data[0].avatar
                    }
                    res.send(user)
                }
            }
        })
        }
    })
    })
    
### <font color='red'>注意：</font>
每一个接口只能返回一个header，即res.send或者其他的只能执行一次，否则会报错
> Error: Can't set headers after they are sent

[Can't set headers after they are sent解决方案][1]


  [1]: https://cnodejs.org/topic/53774ffecbcc396349ca1155
  
---

## 后续
1. 通过ajax不能上传超过100K的图片，怎么解决？
2. 没有实现上传失败的处理方案

后续慢慢填坑。。。。