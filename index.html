<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="personal develop">
<meta property="og:type" content="website">
<meta property="og:title" content="yezi">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="yezi">
<meta property="og:description" content="personal develop">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yezi">
<meta name="twitter:description" content="personal develop">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>yezi</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?84faf04b055e622097ae9117a8d764c0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yezi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/01/一个简单的MVVM-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yezi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/01/一个简单的MVVM-二/" itemprop="url">一个简单的MVVM(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-01T20:41:39+08:00">
                2017-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/09/01/一个简单的MVVM-二/" class="leancloud_visitors" data-flag-title="一个简单的MVVM(二)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一个简单的MVVM（二）"><a href="#一个简单的MVVM（二）" class="headerlink" title="一个简单的MVVM（二）"></a>一个简单的MVVM（二）</h1><hr>
<p>一个MVVM框架有五个部分，分别是：</p>
<ol>
<li><code>sf.js</code> 框架的入口，定义了框架的类</li>
<li><code>watcher.js</code> 用来监听data的数据改变，原理是赋值器劫持</li>
<li><code>scanner.js</code> 扫描dom树，找出<code>sf-</code> 标志的属性和<code>{{value}}</code> 的写法，并且生成map</li>
<li><code>render.js</code> 用来渲染对应属性数据</li>
<li><code>boundItem.js</code> 定义scanner的map的类型和相关<code>sf-</code> 监听函数</li>
</ol>
<p>这次是仿写VUE的MVVM框架，用法和VUE基本类似</p>
<h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><pre><code>var sf = new SegmentFault({
  data: {
    message1: &apos;单向绑定&apos;,
    message2: &apos;this is message2&apos;,
    value: &apos;双向绑定&apos;,
    arr: {
      name: &apos;yezi&apos;,
      song: [&apos;五月天&apos;, &apos;知足&apos;, &apos;倔强&apos;],
      love:{
        live:{
          a:&apos;yezi 3 time&apos;
        }
      }
    }
  }
})
</code></pre><p><code>data</code> 用来绑定数据<br><code>SegmentFault</code> MVVM框架的类</p>
<h2 id="SegmentFault-类"><a href="#SegmentFault-类" class="headerlink" title="SegmentFault 类"></a>SegmentFault 类</h2><pre><code>let SegmentFault = class SegmentFault {
  constructor ({data = {}} = {}) {
    this.data = data
    // 用来维护viewModel和被绑定的view之间的关系
    this.viewViewModelMap = []
    this.init()
  }
  // 类的初始化
  init () {}
  // 手动更新dom
  refresh () {}
</code></pre><h2 id="watcher-js"><a href="#watcher-js" class="headerlink" title="watcher.js"></a>watcher.js</h2><pre><code>export class Watcher {
  constructor(sf) {
    this.sf = sf
    this.data = sf.data;
    // 监听数据，然后执行回调,这里是更新dom树
    this.observe(sf.refresh)
  }
  observe(callback) {
    let data = this.data;
    let sf = this.sf;
    // 定义循环函数，监听多层对象，详细可以看一个简单的MVVM（一）
    var define = function (data) {
      Object.keys(data).forEach((key) =&gt; {
        let value = data[key]
        Object.defineProperty(data, key, {
          get: function () {
            return value
          },
          set: function (newValue) {
            if (newValue === value) {
              return
            }
            value = newValue
            callback.call(sf)
          }
        })
        if (Object.prototype.toString.call(data[key]) === &apos;[object Object]&apos; || Object.prototype.toString.call(data[key]) === &apos;[object Array]&apos;) {
          define(data[key])
        }
      })
    }
    define(data)
  }
}
</code></pre><h2 id="scanner-js"><a href="#scanner-js" class="headerlink" title="scanner.js"></a>scanner.js</h2><pre><code>import {BoundItem} from &apos;./boundItem&apos;
export class Scanner {
  constructor (sf) {
    this.sf = sf
    this.results = []
  }
  // 遍历dom下面所有节点，寻找sf- 和{{}}
  findSf (dom) {
    let children = dom.children
    // 判断children是否为纯数组
    if (!children.push) {
      children = [].slice.call(children)
    } 
    children.forEach((key, index) =&gt; {
      let children = key.children
      if(children &amp;&amp; children.length &gt; 0) {
        // 如果子节点还有节点，则进行递归
        this.findSf(key)
      } else {
      // 获取节点所有属性
        var atrs = key.attributes
        atrs = [].slice.call(atrs)
        // 如果在该节点找到{{}}型数据，则bindData为true，否则为false
        let bindData = /\{\{(\w){1,}([\.\w]*)(\w){1,}\}\}/g.test(key.innerText)
        let type = null , expression = null, el = key
        if (atrs.length !== 0) {
        // 遍历属性，找到sf-标签的属性，保存属性名和值
          atrs.forEach((atr) =&gt; {
            if (/^(sf-)/g.test(atr.name)) {
              type = atr.name
              expression = atr.nodeValue
            }
          })
        }
        // 保存数据，形成dom --&gt; 数据的map
        let item = new BoundItem(type, expression, el, this.sf, bindData)
        this.results.push(item)
      }
    })
  }
  scanBindDOM () {
    let body = document.getElementsByTagName(&apos;body&apos;)[0]
    this.findSf(body)
    return this.results
  }
}
</code></pre><h2 id="boundItem-js"><a href="#boundItem-js" class="headerlink" title="boundItem.js"></a>boundItem.js</h2><pre><code>export class BoundItem {
  constructor(type = null, expression = null, element = null, sf = null, bindData = null) {
    this.type = type;
    this.expression = expression;
    this.el = element;
    this.bindData = bindData;
    this.sf = sf;
    this.listen()
  } 
  // 这里只用两个属性做例子
  listen () {
    let el = this.el
    let sf = this.sf
    let expression = this.expression
    if (el.nodeName === &apos;INPUT&apos;) {
      el.addEventListener(&apos;input&apos;, () =&gt; {
        sf.data[expression] = el.value
      }, false)
    }
  }
}
</code></pre><h2 id="render-js"><a href="#render-js" class="headerlink" title="render.js"></a>render.js</h2><pre><code>export class Renderer{
  constructor (data) {
    this.data = data
  }
  render (boundItem) {
    let objValue = null
    let {type, expression, el, sf, bindData} = boundItem
    // 替换{{}}
    var pattern1 = new RegExp(/\{\{(\w){1,}([\.\w]*)(\w){1,}\}\}/g)
    // 绑定sf-
    var pattern2 = new RegExp(`/\{\{${type}\}\}/g`)
    // bindData为true表示存在{{}}
    if (bindData) {
      // 保存{{message}}
      let expressionText = el.innerText.match(pattern1)[0]
      // 取得message，使得可以从data中获取真实数据
      let expressionData  = expressionText.match(/(\w){1,}([\.\w]*)(\w){1,}/g)[0]
      // 多重对象绑定的取值 比如 arr.name.song
      let objArr = expressionData.split(&apos;.&apos;)
      objValue = this.data[objArr[0]]
      console.log(&apos;objArr:&apos;, objArr)
      // 循环取值
      if (objArr.length &gt;= 2) {
        objArr.forEach((obj, index) =&gt; {
          if (index &gt;= 1) {
            objValue = objValue[obj]
          }
        })
      }
      // 替换模板，赋值
      el.innerText = el.innerText.replace(expressionText, objValue)
      // 这一步是为了防止不断渲染
      boundItem.bindData = false
    }
    // 对特定类型的处理
    if (type === &apos;sf-text&apos;) {
      el.innerHTML = this.data[expression]
    } else if (type === &apos;sf-value&apos;) {
      el.value = this.data[expression]
    }
  }
}
</code></pre><h2 id="最后，再重写主函数"><a href="#最后，再重写主函数" class="headerlink" title="最后，再重写主函数"></a>最后，再重写主函数</h2><pre><code>import {Watcher} from &apos;./watcher&apos;;
import {Scanner} from &apos;./scanner&apos;;
import {Renderer} from &apos;./render&apos;;
let SegmentFault = class SegmentFault {
  constructor ({data = {}} = {}) {
    this.data = data
    // 用来维护viewModel和被绑定的view之间的关系
    this.viewViewModelMap = []
    this.init()
  }
  init () {
    // 监听sf-数据变化
    let watcher = new Watcher(this)
    let scanner = new Scanner(this)
    this.render = new Renderer(this.data)
    this.viewViewModelMap = scanner.scanBindDOM()
    this.viewViewModelMap.forEach((boundItem) =&gt; {
      this.render.render(boundItem)
    })
  }
  refresh () {
    this.viewViewModelMap.forEach((boundItem) =&gt; {
      this.render.render(boundItem)
    })
  }
}
// 测试代码
var sf = new SegmentFault({
  data: {
    message1: &apos;单向绑定&apos;,
    message2: &apos;this is message2&apos;,
    value: &apos;双向绑定&apos;,
    arr: {
      name: &apos;yezi&apos;,
      song: [&apos;五月天&apos;, &apos;知足&apos;, &apos;倔强&apos;],
      love:{
        live:{
          a:&apos;yezi 3 time&apos;
        }
      }
    }
  }
})

setTimeout(() =&gt; {
  console.log(&apos;setTimeout&apos;)
  sf.data.arr.name = &apos;feifei&apos;
  // sf.data.value = &apos;change message2&apos;
}, 3000);
</code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>实现了：</p>
<ol>
<li>的文本绑定</li>
<li>实现多层对象绑定</li>
<li>双向绑定sf-value</li>
<li>单向绑定sf-text</li>
<li>data数据监听</li>
</ol>
<p>未实现：</p>
<ol>
<li>同一个节点多个绑定（在render加一层循环即可实现）</li>
<li>其他功能</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/阿里面试题目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yezi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/阿里面试题目/" itemprop="url">阿里面试题目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T18:38:52+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/24/阿里面试题目/" class="leancloud_visitors" data-flag-title="阿里面试题目">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="阿里面试题目"><a href="#阿里面试题目" class="headerlink" title="阿里面试题目"></a>阿里面试题目</h1><hr>
<p><img src="http://wx3.sinaimg.cn/mw690/a359ab18gy1fiv039e3k4j210o0faq3r.jpg" alt="第一题"></p>
<p>  实现思路： 递归到最后一层，然后在相应位置填上数值，返回上一层，在相应位置填上当前值的数值，填值的方法是反向填值，个数为下层的个数相乘，然后进入下一轮</p>
<p>  比如有一个数据如下：</p>
<pre><code>data = [
    [&apos;yezi&apos;],
    [2016, 2017],
    [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]
]
</code></pre><p>步骤：</p>
<ol>
<li>递归到最后一层 <code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>，在第三行的位置开始填数值a,b,c；然后保存上一层要开始填值得列数，这里是<code>column = 3</code></li>
<li>回到第二层<code>[2016, 2017]</code>, 这时循环的数值是2016，然后设置<code>key = column - i - 1</code> 让2016在第二行第三列的位置开始往前填，相应填在第三列 —&gt; 第二列 —&gt; 第一列位置， 然后开始下一次循环，i++</li>
<li>这时到了2017，判断他有后续兄弟，于是递归到最后一层，再次从<code>column</code> 的位置开始填写，最后回到步骤1</li>
</ol>
<p>这个算法有两步：</p>
<ol>
<li>第一步是计算每行每次需要填写的个数，比如data数据，对于第一层，yezi要填写的个数是后面层数长度相乘，即2*3 = 6， 2016和2017分别要填写3个，而第三层数值各一个</li>
<li>第二步就是进行递归</li>
</ol>
<p>代码如下：</p>
<pre><code>window.onload = function () {
  function fillSheet(sheet, data) {
    var index = 0;
    if (data.length === 0) return
    var column = 0
    var args = [].slice.call(arguments[1])
    // 计算每一行应该描绘多少个
    var amount = []
    var totalColumn = []
    var caculate = function () {
      args.map((key, index) =&gt; {
        amount.push(key.length)
      })
      while (amount.length !== 0) {
        amount.shift()
        let total = amount.reduce(function (before, next) {
          return before * next
        }, 1)
        totalColumn.push(total)
      }
    }
    // 给特定数组描绘表格
    var setValue = function (index, data) {
      for (let i = 0; i &lt; data[index].length; i++) {
        let currentKey = data[index][i]
        let next = index + 1
        let arr = data[next]
        let key = null
        if (arr) {
          // 开始递归
          setValue(next, data)
          // 返回这层时填写当前数值
          for (let i = 0; i &lt; totalColumn[index]; i++) {
            key = column - i - 1
            sheet.setValue(index, key, currentKey)
          }
        } else {
          // 最后一层填写表格
          key = column
          sheet.setValue(index, key, currentKey)
          column = key + 1
        }
      }
    }
    caculate(args)
    setValue(index, data)
  }
  class Sheet {
    setValue (row, column, value) {
      var top = row * 40
      var left = column * 100
      var div = document.createElement(&apos;div&apos;)
      div.style.display = &apos;inline-block&apos;
      div.style.position = &apos;absolute&apos;
      div.style.left = left + &apos;px&apos;
      div.style.top = top + &apos;px&apos;
      div.innerHTML = value
      document.body.appendChild(div)
    }
  }
  var data = [
  [&apos;CNY&apos;, &apos;china&apos;],
  [2016],
  [&apos;jack&apos;, &apos;yezi&apos;],
  [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
  ]
  var sheet = new Sheet()
  fillSheet(sheet, data)
  console.log(&apos;over&apos;)
}
</code></pre><p>其中 <code>Sheet</code> 是为了测试代码效果而写的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/从零开始学习react第五天/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yezi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/从零开始学习react第五天/" itemprop="url">从零开始学习react第五天</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T18:27:24+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/24/从零开始学习react第五天/" class="leancloud_visitors" data-flag-title="从零开始学习react第五天">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从零开始学习react第五天"><a href="#从零开始学习react第五天" class="headerlink" title="从零开始学习react第五天"></a>从零开始学习react第五天</h1><hr>
<p>第五天，这次学习如何使用react-router</p>
<h2 id="安装-react-router"><a href="#安装-react-router" class="headerlink" title="安装 react-router"></a>安装 <code>react-router</code></h2><blockquote>
<p>npm install react-router –save</p>
</blockquote>
<h3 id="踩坑点：-这里我用的是2-x版本，如果使用4-x版本，下面方法就不支持了"><a href="#踩坑点：-这里我用的是2-x版本，如果使用4-x版本，下面方法就不支持了" class="headerlink" title="踩坑点： 这里我用的是2.x版本，如果使用4.x版本，下面方法就不支持了"></a>踩坑点： 这里我用的是2.x版本，如果使用4.x版本，下面方法就不支持了</h3><h2 id="项目加入router"><a href="#项目加入router" class="headerlink" title="项目加入router"></a>项目加入router</h2><p>新建 <code>root.js</code>， 代码如下：</p>
<pre><code>import React from &apos;react&apos;;
import {Router, Route, hashHistory, IndexRoute} from &apos;react-router&apos;
import App from &apos;./components/app&apos;
import List from &apos;./components/list&apos;
import Child from &apos;./components/child&apos;
export default class Root extends React.Component {
  render () {
    return (
      &lt;Router history={hashHistory}&gt;
        &lt;Route path=&quot;/&quot; component={App} /&gt;
        &lt;Route path=&quot;/list&quot; component={List}&gt;
          &lt;IndexRoute component={Child} /&gt;
          &lt;Route path=&quot;/child&quot; component={Child} /&gt;
          &lt;Route path=&quot;/App&quot; component={App} /&gt;
        &lt;/Route&gt;
      &lt;/Router&gt;
    )
  }
}
</code></pre><ol>
<li><code>Router</code> 定义一个路由</li>
<li><code>history={hashHistory}</code> 定义路由路径</li>
<li><code>path</code> 定义路由路径</li>
<li><code>IndexRoute</code> 进入路由list时，默认显示该子路由，相当于子路由默认页，如果不加这个，在进入list时候并不会显示路由</li>
</ol>
<h3 id="踩坑点："><a href="#踩坑点：" class="headerlink" title="踩坑点："></a>踩坑点：</h3><ol>
<li>这里的写法是 <code>path=&quot;/child&quot;</code> 这样可以通过url <code>xxxx.com/child</code> 访问到页面，但是如果这样写 <code>path=&quot;child&quot;</code> 把 <code>/</code> 去掉，就不能通过路由访问到了，但是也不会报错，把他设置成子路由首页也是没问题的</li>
<li>上面代码中，用户访问/child时，会先加载list组件，然后在它的内部再加载child组件</li>
</ol>
<h3 id="新增list-js，代码如下："><a href="#新增list-js，代码如下：" class="headerlink" title="新增list.js，代码如下："></a>新增list.js，代码如下：</h3><pre><code>import React from &apos;react&apos;;
export default class List extends React.Component {
  render () {
    return (
      &lt;div&gt;
        &lt;div&gt;this is list&lt;/div&gt;
        {this.props.children}
      &lt;/div&gt;
    )
  }
}
</code></pre><p><code>{this.props.children}</code> 这里的代码是为了显示子路由，如果不加上这个，子路由就无法显示</p>
<p>然后就可以运行整个项目，路由搭建成功</p>
<h2 id="Link-跳转路由"><a href="#Link-跳转路由" class="headerlink" title="Link 跳转路由"></a>Link 跳转路由</h2><p>Link组件用于取代<a>元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是<a>元素的React 版本，可以接收Router的状态</a></a></p>
<pre><code>import {Link} from &apos;react-router&apos;;
render () {
    return (
        &lt;div&gt;
            // ...
            &lt;Link to=&apos;/list&apos; activeStyle={{color: 'red'}}&gt;to list&lt;/Link&gt;
            &lt;Link to=&apos;/child&apos; activeClassName=&quot;active&quot;&gt;to child&lt;/Link&gt;
        &lt;/div&gt;
    )
}
</code></pre><p><code>activeStyle</code> 使用Link组件的activeStyle属性添加行内样式<br><code>activeClassName</code> 使用Link组件的activeClassName属性添加css样式</p>
<h3 id="在Router组件之外的跳转"><a href="#在Router组件之外的跳转" class="headerlink" title="在Router组件之外的跳转"></a>在Router组件之外的跳转</h3><p>在Router组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写：</p>
<pre><code>import { browserHistory } from &apos;react-router&apos;;
browserHistory.push(&apos;/some/path&apos;);
</code></pre><p>更多用法请查阅这里 <a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="external">React Router 使用教程</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/一个简单的MVVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yezi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/一个简单的MVVM/" itemprop="url">一个简单的MVVM(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T14:41:15+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/14/一个简单的MVVM/" class="leancloud_visitors" data-flag-title="一个简单的MVVM(一)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MVVM框架"><a href="#MVVM框架" class="headerlink" title="MVVM框架"></a>MVVM框架</h1><hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>基于 Vue 数据绑定方式实现MVVM框架</p>
<p>这次基于MVVM框架实现的使用方法：</p>
<pre><code>// 定义监听对象
data = {
  a: &quot;before&quot;,
  b: [1, 2, 3, 4],
  c: {
    d: &quot;child d&quot;,
    f: &quot;child f&quot;
  }
}
var oberver = new Listen(data)
</code></pre><p>数据定义包括了基本类型，对象的嵌套，还有数组的处理<br>参考： <a href="http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/" target="_blank" rel="external">JavaScript实现MVVM</a></p>
<h2 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h2><p>通过 <code>Object.defineProperty</code> 方法，设置对象的 <code>setter</code> <code>getter</code> 构造器，完成对数据的监听</p>
<h2 id="1-对象的监听"><a href="#1-对象的监听" class="headerlink" title="1. 对象的监听"></a>1. 对象的监听</h2><p>定义监听函数 Listen：</p>
<pre><code>class Listen {
    constructor (obj) {
        // 对obj进行类型判断
        if (Object.prototype.toString.call(obj) !== &apos;[object Object]&apos;) {
            return console.log(&apos;this obj isn&apos;t a object, please make sure&apos;)
        }
        this.observe(obj)
    }
    observe (obj) {
         // 遍历data里面的属性，设置set/getter
        Object.keys(obj).forEach((key, index, keyArray) =&gt; {
            var oldVal =  = obj[key]
            Object.defineProperty(obj, key, {
                get: function () {
                    return oldVal
                }.bind(this),
                set: function (newVal) {
                    // 做一些处理，这里测试用了打印函数
                    console.log(`oldVal=${oldVal} --- newVal=${newVal}`)
                    oldVal = newVal
                }.bind(this)
            })
        })
    }
}
</code></pre><p>这里使用<code>Object.prototype.toString.call(obj)</code> 判断数据的类型，详细内容可以看这个： <a href="http://www.cnblogs.com/flyjs/archive/2012/02/20/2360504.html99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/" target="_blank" rel="external">JS数据类型判断</a></p>
<h3 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h3><pre><code>var data = {
  a: &quot;before&quot;,
  b: [1, 2, 3, 4],
  c: {
    d: &quot;child d&quot;,
    f: &quot;child f&quot;
  }
}
var observer = new Listen(data)
data.a = &quot;after&quot;
data.b = &quot;after&quot;
</code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><blockquote>
<p>oldVal=before — newVal=after<br>oldVal=1,2,3,4 — newVal=after</p>
</blockquote>
<p>好了，现在我们这个框架可以监听一级数据了，可是对于二级数据，比如 <code>data.c.d</code> ，修改它的值，却没有出现监听。<br>原因是代码里面只处理了一级数据，现在我们可以再加个判断，如果当前obj[key]是属于对象，则进行迭代</p>
<h3 id="处理二级数据："><a href="#处理二级数据：" class="headerlink" title="处理二级数据："></a>处理二级数据：</h3><pre><code>if (Object.prototype.toString.call(obj[key]) === &apos;[object Object]&apos; || Object.prototype.toString.call(obj[key]) === &apos;[object Array]&apos;) {
          this.observe(obj[key])
        }
</code></pre><p>将这段代码加到 <code>Object.keys(obj).forEach</code> 下面，然后测试结果</p>
<blockquote>
<p>data.c.d = “after”<br>data.b<a href="http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/" target="_blank" rel="external">1</a> = “after”</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>oldVal=child d — newVal=after<br>oldVal=2 — newVal=after</p>
</blockquote>
<h2 id="对数组方法的处理"><a href="#对数组方法的处理" class="headerlink" title="对数组方法的处理"></a>对数组方法的处理</h2><p>原理： 在数组的原型链上加多一层，变成:</p>
<blockquote>
<p>objArray —&gt; addChain —&gt; Array</p>
</blockquote>
<p>这样就可以监听Array方法，而且也不必重写Array的原生方法</p>
<h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><pre><code>overrideArrayProto (array) {
      // 保存原始 Array 原型
      var originalProto = Array.prototype,
      // 通过 Object.create 方法创建一个对象，该对象的原型就是Array.prototype
      overrideProto = Object.create(Array.prototype),
      self = this,
      result;
      // 遍历要重写的数组方法
      var OAM = [&apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;, &apos;unshift&apos;, &apos;splice&apos;, &apos;sort&apos;, &apos;reverse&apos;]
      Object.keys(OAM).forEach((key, index, keyArray) =&gt; {
        var method = OAM[index],
        oldArray = [];
        // 使用 Object.defineProperty 给 overrideProto 添加属性，属性的名称是对应的数组函数名，值是函数
        Object.defineProperty(overrideProto, method, {
          value: function () {
            // 复制数组
            // this指向array
            oldArray = this.slice(0)
            console.log(&apos;arguments: &apos;, arguments)
            // 将arguments转化为数组
            var arg = [].slice.apply(arguments)
            result = originalProto[method].apply(this, arg)
            // 执行回调，这里测试用打印函数
            console.log(`oldArray=${oldArray} --- newVArray=${result}`)
            return result
          },
          enumerable: false
        })
      })
      // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto
      array.__proto__ = overrideProto
    }
</code></pre><p>在<code>observe</code>开头加上一下代码：</p>
<pre><code>// 如果发现监测的对象是数组的话就要调用 overrideArrayProto 方法
      if(Object.prototype.toString.call(obj) === &apos;[object Array]&apos;){
        this.overrideArrayProto(obj)
      }
</code></pre><h3 id="测试代码：-1"><a href="#测试代码：-1" class="headerlink" title="测试代码："></a>测试代码：</h3><pre><code>data.b[1] = &quot;after&quot;
data.b.pop()
data.b.push(121)
console.log(data.b)
</code></pre><h3 id="结果输出："><a href="#结果输出：" class="headerlink" title="结果输出："></a>结果输出：</h3><blockquote>
<p>oldVal=2 — newVal=after<br>oldArray=1,after,3,4 — newVArray=4<br>oldArray=1,after,3 — newVArray=4<br>[1, “after”, 3, 121]</p>
</blockquote>
<p>一个简单的MVVM框架到此结束</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/12/从零开始学习react第四天/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yezi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/从零开始学习react第四天/" itemprop="url">从零开始学习react第四天</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T17:41:25+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/12/从零开始学习react第四天/" class="leancloud_visitors" data-flag-title="从零开始学习react第四天">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从零开始学习react的第四天"><a href="#从零开始学习react的第四天" class="headerlink" title="从零开始学习react的第四天"></a>从零开始学习react的第四天</h1><hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>昨天我们已经添加了对于css，图片之类的处理，那么我们现在就可以开始我们的项目了，对于完全没了解react语法的，可以先去看阮一峰老师的教程： <a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="external">react入门</a><br>我这里就不再重复写教程了，主要了解react怎么render，如何绑定数据，生命周期，借下来我给个简单例子说明一下，热身一下。</p>
<h3 id="主函数-app-js"><a href="#主函数-app-js" class="headerlink" title="主函数 app.js"></a>主函数 app.js</h3><pre><code>import ComponentHeader from &apos;./header&apos;
render() {
    return (
      &lt;div&gt;
        &lt;ComponentHeader/&gt;
        &lt;h1&gt;this is mainBody page&lt;/h1&gt;
      &lt;/div&gt;,
      document.getElementById(&apos;app&apos;)
    )
}
</code></pre><p><code>ComponentHeader</code> 作为组件导入<br>注意： 导入的组件一定要大写 <code>ComponentHeader</code> 不能写成 <code>componentHeader</code></p>
<h3 id="子函数-header-js"><a href="#子函数-header-js" class="headerlink" title="子函数 header.js"></a>子函数 header.js</h3><pre><code>import React from &apos;react&apos;;
export default class Header extends React.Component {
  constructor () {
    super()
    this.state = {
      title: &apos;this is header page&apos;
    }
  }
  changeInfo () {
    this.setState({
      info: &apos;change info&apos;
    })
  }
  render () {
    return (
      &lt;div&gt;
      &lt;h1&gt;{this.state.title}&lt;/h1&gt;
      &lt;input type=&apos;button&apos; type=&apos;button&apos; onClick={this.changeInfo.bind(this)}/&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p><code>constructor</code> 是react组件的构造函数<br><code>this.state</code> 设置组件的内部初始值，在<code>constructor</code> 里面定义<br><code>super()</code> 初始化基类的数据<br><code>{this.state.title}</code> react数据的绑定<br><code>changeInfo</code> 自定义的函数，用来测试setState作用<br><code>this.setState</code> 用来改变state<br><code>export default</code> 是将组件导出来<br><code>input</code> 注意事件绑定的方法 <code>bind</code> ，否则会报错</p>
<blockquote>
<p>Cannot read property ‘setState’ of null</p>
</blockquote>
<p>简单地过了一遍基本知识点，接下来说说今天学习的react父子组件通信</p>
<hr>
<h2 id="react父子组件通信"><a href="#react父子组件通信" class="headerlink" title="react父子组件通信"></a>react父子组件通信</h2><h3 id="父向子组件传参"><a href="#父向子组件传参" class="headerlink" title="父向子组件传参"></a>父向子组件传参</h3><p>在父组件app.js里面：</p>
<pre><code>render() {
    return (
      &lt;div&gt;
        &lt;ComponentHeader info={this.state.toHeader}/&gt;
        &lt;h1&gt;this is mainBody page&lt;/h1&gt;
      &lt;/div&gt;,
      document.getElementById(&apos;app&apos;)
    )
}
</code></pre><p>在要传递上面写上要传递的参数，左边 <code>info</code> 表示参数名，右边 <code>this.state.toHeader</code> 是传递参数值</p>
<p>在子组件header.js里面：</p>
<pre><code>export default class Header extends React.Component {
  // ...
  render () {
    return (
      &lt;div&gt;
      &lt;h1&gt;this is header page&lt;/h1&gt;
      &lt;p&gt;info: {{this.props.info}}&lt;/p&gt;
      &lt;p&gt;子页面输入: &lt;input type=&apos;button&apos; type=&apos;text&apos; onChange={this.props.changeInput}/&gt;&lt;/p&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>通过 <code>this.props.[name]</code> 获取传进来的数据</p>
<h3 id="子组件向父组件传参"><a href="#子组件向父组件传参" class="headerlink" title="子组件向父组件传参"></a>子组件向父组件传参</h3><p>要求： 子组件输入数据，在父组件中显示</p>
<p>header.js子组件：</p>
<pre><code>render () {
    return (
      &lt;div&gt;
      // ...
      &lt;p&gt;子页面输入：&lt;input type=&apos;text&apos; onChange={this.props.changeInput}/&gt; &lt;/p&gt;
      &lt;/div&gt;
    )
  }
</code></pre><p>app.js父组件：</p>
<pre><code>changeInput (event) {
    this.setState({
      age: event.target.value，
      title: &apos;this is mainBody page&apos;,
      toHeader: &apos;info comes from mainBody page&apos;
    })
  }
  render() {
    return (
      &lt;div&gt;
        // ...
        &lt;ComponentHeader info={this.state.toHeader} changeInput={this.changeInput.bind(this)}/&gt;
        &lt;p&gt;age: {this.state.age}&lt;/p&gt;
      &lt;/div&gt;,
      document.getElementById(&apos;app&apos;)
    )
  }
</code></pre><p>父组件设置函数 <code>changeInput</code> ，然后再子组件处传入<br>子组件向父组件传值的原理是通过由父组件传递函数给子组件，在子组件运行父组件的形式，达到子向父组件传参</p>
<h2 id="一个传参技巧"><a href="#一个传参技巧" class="headerlink" title="一个传参技巧"></a>一个传参技巧</h2><p>通过<code>{...this.props}</code> 这样的方式，可以一次性传递当前页面的所有由父组件传递过来的参数<br>比如有这样一个场景：<br>父组件 –&gt; 子组件 –&gt; 孙子组件<br>孙子组件要获取父组件传递的所有参数，就可以用这样形式获取，如果参数发生变化，也只需要改动父组件这一处</p>
<h2 id="对于props的设定"><a href="#对于props的设定" class="headerlink" title="对于props的设定"></a>对于props的设定</h2><h3 id="设定传递参数的默认值，-name-是组件名字"><a href="#设定传递参数的默认值，-name-是组件名字" class="headerlink" title="设定传递参数的默认值，[name]是组件名字"></a>设定传递参数的默认值，[name]是组件名字</h3><pre><code>[name].defaultProps = {
    &apos;username&apos;: &apos;yezi&apos;
}
</code></pre><h3 id="设置props类型"><a href="#设置props类型" class="headerlink" title="设置props类型"></a>设置props类型</h3><pre><code>[name].propsTypes = {
    &apos;username&apos;: React.PropTypes.string.isRequired
}
</code></pre><p>设置 <code>username</code> 必须为 <code>string</code> 类型，<code>required</code> 设置不能为空</p>
<hr>
<h2 id="与VUE的父子传参方式对比"><a href="#与VUE的父子传参方式对比" class="headerlink" title="与VUE的父子传参方式对比"></a>与VUE的父子传参方式对比</h2><h3 id="vue父组件向子组件传参数的方式和react基本相似，都是通过传递props-name-的值"><a href="#vue父组件向子组件传参数的方式和react基本相似，都是通过传递props-name-的值" class="headerlink" title="vue父组件向子组件传参数的方式和react基本相似，都是通过传递props[name]的值"></a>vue父组件向子组件传参数的方式和react基本相似，都是通过传递props[name]的值</h3><h3 id="vue子组件向父组件传参的方式和react有极大的不同"><a href="#vue子组件向父组件传参的方式和react有极大的不同" class="headerlink" title="vue子组件向父组件传参的方式和react有极大的不同"></a>vue子组件向父组件传参的方式和react有极大的不同</h3><ol>
<li>vue通过$emit(name, [props])函数达到向上传递，然后再父组件监听派发上来的函数，然后<font color="blue">在父函数中处理</font></li>
<li>react依然通过this.props方式向子组件传进父组件参数，<font color="blue">在子组件中处理</font></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/11/从零开始学习react第三天/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yezi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/11/从零开始学习react第三天/" itemprop="url">从零开始学习react第三天</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-11T17:47:01+08:00">
                2017-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/11/从零开始学习react第三天/" class="leancloud_visitors" data-flag-title="从零开始学习react第三天">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从零开始学习react第三天"><a href="#从零开始学习react第三天" class="headerlink" title="从零开始学习react第三天"></a>从零开始学习react第三天</h1><hr>
<p>前面我们已经配置出一个基本的react-cli，但是依然还没有完善好，因为现在的配置仅仅是打包的js和html格式的文件，对于图片，css，字体这些文件还无法进行打包处理，今天我们就开始给项目添加这些功能。</p>
<h2 id="第一种：内联样式"><a href="#第一种：内联样式" class="headerlink" title="第一种：内联样式"></a>第一种：内联样式</h2><h3 id="首先按我们用index-js作为解说"><a href="#首先按我们用index-js作为解说" class="headerlink" title="首先按我们用index.js作为解说"></a>首先按我们用index.js作为解说</h3><pre><code>import React from &apos;react&apos;;
import { render } from &apos;react-dom&apos;;
if (module.hot) {
  module.hot.accept();
}
render(
  &lt;div&gt;
  &lt;h1&gt;hello world&lt;/h1&gt;
  &lt;/div&gt;,
  document.getElementById(&apos;app&apos;)
);
</code></pre><p>在react中定义样式：</p>
<pre><code>const styleIndex = {
    fontSize: &quot;14px&quot;,
    // react不推荐这种写法
    &quot;padding-top&quot;: &quot;20px&quot;
}
</code></pre><p>在 <code>index.js</code> 文件中写入</p>
<pre><code>import React from &apos;react&apos;;
import { render } from &apos;react-dom&apos;;
if (module.hot) {
  module.hot.accept();
}
const styleIndex = {
  // ...
}
render(
  &lt;div style={styleIndex}&gt;
  &lt;h1&gt;hello world&lt;/h1&gt;
  &lt;/div&gt;,
  document.getElementById(&apos;app&apos;)
);
</code></pre><p>最后结果会将样式内联到<code>div</code>上面，这样的方式有几个特点：</p>
<ol>
<li>不会造成全局污染</li>
<li>css写法和传统写法不同</li>
<li>嵌入的方式是内联，不利于修改</li>
<li>无法写动画 / 伪类</li>
</ol>
<h3 id="这种写法支持react表达式"><a href="#这种写法支持react表达式" class="headerlink" title="这种写法支持react表达式"></a>这种写法支持react表达式</h3><blockquote>
<p>backgroundColor: (this.state.isPadding) ? “#ccc” : “#ddd”<br>注意这里用的是圆括号</p>
</blockquote>
<pre><code>const styleIndex = {
  fontSize: &quot;14px&quot;,
  // react不推荐这种写法
  &quot;padding-top&quot;: (this.state.isPadding) ? &quot;20px&quot; : 0,
  // 支持表达式写法
  backgroundColor: (this.state.isPadding) ? &quot;#ccc&quot; : &quot;#ddd&quot;,
  color: &quot;#fff&quot;
}
</code></pre><h2 id="CSS-module"><a href="#CSS-module" class="headerlink" title="CSS module"></a>CSS module</h2><p>利用 <code>css-loader</code> <code>style-loader</code> 两个module，在webpack配置，就可以在需要运用js的文件下require进来，当成对象使用</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><blockquote>
<p>npm install –save-dev css-loader style-loader</p>
</blockquote>
<h3 id="创建header-js"><a href="#创建header-js" class="headerlink" title="创建header.js"></a>创建header.js</h3><p>在<code>src</code> 目录下创建一个文件夹<code>components</code>，用来存放我们的组件<br>然后在<code>components</code> 下创建`header.js</p>
<pre><code>import React from &apos;react&apos;;
export default class HeaderTpl extends React.Component {
  constructor () {
    super()
  }
  render () {
    return (
      &lt;div&gt;
        &lt;h1&gt;this is header&lt;/h1&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><h3 id="编写css"><a href="#编写css" class="headerlink" title="编写css"></a>编写css</h3><p>在 <code>src/css</code> 目录下创建一个<code>header.css</code>：</p>
<pre><code>.header h1{
  background-color: #ccc;
  color: #fff;
}
</code></pre><h3 id="配置webpack-base-conf-js"><a href="#配置webpack-base-conf-js" class="headerlink" title="配置webpack.base.conf.js"></a>配置webpack.base.conf.js</h3><pre><code>{
  test: /\.css$/,
  loader: &quot;style-loader!css-loader?modules&amp;localIdentName=[path][name]---[local]---[hash:base64:5]&quot;
}
</code></pre><p>?modules&amp;localIdentName=[path][name]—[local]—[hash:base64:5]<br>这段参数的意思是启动CSSmodule ，然后让编译后的css的名字改成<code>[path][name]---[local]---[hash:base64:5]</code>，这样可以达到限定css作用域</p>
<h3 id="在header-js引用css"><a href="#在header-js引用css" class="headerlink" title="在header.js引用css"></a>在header.js引用css</h3><pre><code>import React from &apos;react&apos;;
import headerStyle from &apos;../css/header.css&apos;
export default class HeaderTpl extends React.Component {
  constructor () {
    super()
  }
  render () {
    return (
      &lt;div className={headerStyle.header}&gt;
        &lt;h1&gt;this is header&lt;/h1&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>通过类似于函数的调用，就可以达到引用css样式效果，而且这里的header.css最后会被编译成 <code>src-css-header---header---19-MS</code></p>
<h3 id="修改index-js文件："><a href="#修改index-js文件：" class="headerlink" title="修改index.js文件："></a>修改index.js文件：</h3><pre><code>import React from &apos;react&apos;;
import headerStyle from &apos;../css/header.css&apos;
export default class HeaderTpl extends React.Component {
  constructor () {
    super()
  }
  render () {
    return (
      &lt;div className={headerStyle.header}&gt;
        &lt;h1&gt;this is header&lt;/h1&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>运行 <code>npm run dev</code> 查看效果</p>
<h3 id="顺便一提，我们上面用的是-classNmae绑定css，如果想用-class-绑定的话，可以安装-babel-plugin-react-html-attrs"><a href="#顺便一提，我们上面用的是-classNmae绑定css，如果想用-class-绑定的话，可以安装-babel-plugin-react-html-attrs" class="headerlink" title="顺便一提，我们上面用的是 classNmae绑定css，如果想用 class 绑定的话，可以安装 babel-plugin-react-html-attrs"></a>顺便一提，我们上面用的是 <code>classNmae</code>绑定css，如果想用 <code>class</code> 绑定的话，可以安装 <code>babel-plugin-react-html-attrs</code></h3><h4 id="在-babelrc中配置"><a href="#在-babelrc中配置" class="headerlink" title="在 .babelrc中配置"></a>在 .babelrc中配置</h4><pre><code>{
  &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;],
  &quot;env&quot;: {
   &quot;development&quot;: {
     &quot;presets&quot;: [&quot;react-hmre&quot;]
   }
  },
  plugins: [&apos;react-html-attrs&apos;]
}
</code></pre><p>添加 <code>plugins: [&#39;react-html-attrs&#39;]</code> </p>
<p>然后我们在header.js里面就可以这样子写：</p>
<pre><code>&lt;div class={headerStyle.header}&gt;
    &lt;h1&gt;this is header&lt;/h1&gt;
  &lt;/div&gt;
</code></pre><p>达到的效果是一样的！ 也更贴近我们的日常使用习惯</p>
<h2 id="另外一种调用css的方式"><a href="#另外一种调用css的方式" class="headerlink" title="另外一种调用css的方式"></a>另外一种调用css的方式</h2><p>首先还原配置</p>
<h3 id="配置webpack-base-conf-js-1"><a href="#配置webpack-base-conf-js-1" class="headerlink" title="配置webpack.base.conf.js"></a>配置webpack.base.conf.js</h3><pre><code>{
  test: /\.css$/,
  loader: &quot;style-loader!css-loader&quot;
}
</code></pre><h3 id="修改header-css："><a href="#修改header-css：" class="headerlink" title="修改header.css："></a>修改<code>header.css</code>：</h3><pre><code>.App-header{
  background-color: #ccc;
  color: #fff;
}
</code></pre><h3 id="在header-js引用css-1"><a href="#在header-js引用css-1" class="headerlink" title="在header.js引用css"></a>在header.js引用css</h3><pre><code>import React from &apos;react&apos;;
import &apos;../css/header.css&apos;
export default class HeaderTpl extends React.Component {
  constructor () {
    super()
  }
  render () {
    return (
      &lt;div className=&quot;App-header&quot;&gt;
        &lt;h1&gt;this is header&lt;/h1&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>这种写法无法避免全局污染</p>
<h2 id="配置sass"><a href="#配置sass" class="headerlink" title="配置sass"></a>配置sass</h2><blockquote>
<p>npm install sass-loader node-sass –save-dev</p>
</blockquote>
<h3 id="在-webpack-base-conf-下面加一个loader"><a href="#在-webpack-base-conf-下面加一个loader" class="headerlink" title="在 webpack.base.conf 下面加一个loader"></a>在 <code>webpack.base.conf</code> 下面加一个loader</h3><pre><code>{
  test: /\.scss$/,
  loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;],
}
</code></pre><p>这样子就行了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/10/从零开始学习react第二天/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yezi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/从零开始学习react第二天/" itemprop="url">从零开始学习react第二天</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T21:56:05+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/10/从零开始学习react第二天/" class="leancloud_visitors" data-flag-title="从零开始学习react第二天">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从零开始学习react第二天"><a href="#从零开始学习react第二天" class="headerlink" title="从零开始学习react第二天"></a>从零开始学习react第二天</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先我们先完善第一天留下来的问题，之前我们用 <code>babel-loader</code> <code>babel-preset-react</code> <code>babel-preset-es2005</code> 三个包将ES6语法转换为ES5，相对于大多数浏览器，这样的设置可能已经足够了，但是对于少数不支持ES5语法的浏览器，这样的设置可能还不够，而且 <code>babel-loader</code> 对于ES6的 <code>promise</code> <code>fetch</code>，ES5的新方法 <code>Object.assign</code> ,虽然能正确运行，但是对于IE9以下的浏览器来说并不能兼容<br>这个时候就需要 <code>polyfill</code></p>
<p>为了能随心所欲地使用ES6语法，这里我推荐使用  <code>babel-polyfill</code> <code>babel-preset-env</code><br>关于 <code>babel-preset-env</code> 的选择原理看这里：<br><a href="https://segmentfault.com/a/1190000010106158" target="_blank" rel="external">21 分钟精通前端 Polyfill 方案</a><br><a href="https://segmentfault.com/q/1010000005596587" target="_blank" rel="external">babel-polyfill和babel-runtime对比</a></p>
<h3 id="安装-babel-polyfill"><a href="#安装-babel-polyfill" class="headerlink" title="安装  babel-polyfill"></a>安装  <code>babel-polyfill</code></h3><blockquote>
<p>npm install babel-polyfill –save</p>
</blockquote>
<h3 id="修改pakage-json配置，让-babel-polyfill-单独插入到html"><a href="#修改pakage-json配置，让-babel-polyfill-单独插入到html" class="headerlink" title="修改pakage.json配置，让 babel-polyfill 单独插入到html"></a>修改pakage.json配置，让 <code>babel-polyfill</code> 单独插入到html</h3><p>为了实现多入口的注入，我们用到 <code>new webpack.optimize.CommonsChunkPlugin(options)</code><br>代码如下：</p>
<pre><code>plugins: [
    // ...
    new webpack.optimize.CommonsChunkPlugin({
        name: &apos;verdor&apos;,
        filename: &apos;polyfill.js&apos;
    }) 
]
// 修改入口文件,增加vendor
entry: {
    app: &apos;./src/index.js&apos;,
    verdor: &apos;babel-polyfill&apos;
}
</code></pre><p>这样运行webpack，可以看到编译后的html下面有两个script文件引用了</p>
<hr>
<p>回到正题，今天学习的是<code>babel-plugin-react-transform</code>的热加载</p>
<h2 id="babel-plugin-react-transform-热加载的实现"><a href="#babel-plugin-react-transform-热加载的实现" class="headerlink" title="babel-plugin-react-transform 热加载的实现"></a>babel-plugin-react-transform 热加载的实现</h2><p>之前我们已经实现了页面的自动刷新，用的命令是：</p>
<blockquote>
<p>webpack-dev-server –inline</p>
</blockquote>
<p>原本想用 <code>react-hot-loader</code> 可是官方已经停止维护，推荐我们使用 <code>babel-plugin-react-transform</code></p>
<h3 id="于是我们先安装包"><a href="#于是我们先安装包" class="headerlink" title="于是我们先安装包"></a>于是我们先安装包</h3><blockquote>
<p>npm install –save-dev babel-plugin-react-transform</p>
</blockquote>
<p>还有一些转换器搭配使用</p>
<blockquote>
<p>npm install –save-dev react-transform-hmr<br>npm install –save-dev react-transform-catch-errors redbox-react</p>
</blockquote>
<p><code>babel-plugin-react-transform</code> 这是个基本的架子<br><code>react-transform-hmr</code> 是真正实现热更新的插件<br><code>react-transform-catch-errors</code> <code>redbox-react</code>  是实现在页面上显示错误，不用每次都打开控制台,可以不安装</p>
<p>要让新建的两个transform生效,只需再安装一个present</p>
<blockquote>
<p>npm install babel-preset-react-hmre –save-dev</p>
</blockquote>
<h3 id="第一次启动"><a href="#第一次启动" class="headerlink" title="第一次启动"></a>第一次启动</h3><blockquote>
<p>npm run dev</p>
</blockquote>
<p>发现结果并不是和我们想象中一样，达到了热刷新，结果还是和以前一样，全面刷新。<br>于是我各种百度，还是不得其解，只好去他们的官网下载了一个<a href="https://github.com/gaearon/react-transform" target="_blank" rel="external">demo</a></p>
<p>发现，他们的demo并不是用 <code>webpack-dev-server</code> 作为服务器，而是用 <code>webpack-dev-middleware</code> 和 <code>webpack-hot-middleware</code> 开启热刷新</p>
<p>于是我开始仿照他们的demo，重构了我的目录结构</p>
<h3 id="重构项目结构"><a href="#重构项目结构" class="headerlink" title="重构项目结构"></a>重构项目结构</h3><p>安装这两个模块</p>
<blockquote>
<p>npm install –save-dev webpack-dev-middleware webpack-hot-middleware</p>
</blockquote>
<p>然后新建一个文件夹build，<font color="blue">把webpack.config.js放进去并且改名为webpack.base.conf.js</font>，然后新建两个文件 <code>webpack.dev.conf.js</code> <code>webpack.prod.conf.js</code></p>
<p>目录结构如下：<br><img src="http://wx1.sinaimg.cn/mw690/a359ab18gy1fieycd93xaj20he08jaa6.jpg" alt="目录结构"></p>
<h4 id="webpack-dev-conf-js-文件主要是在开发环境所要用到的配置，代码如下："><a href="#webpack-dev-conf-js-文件主要是在开发环境所要用到的配置，代码如下：" class="headerlink" title="webpack.dev.conf.js 文件主要是在开发环境所要用到的配置，代码如下："></a><code>webpack.dev.conf.js</code> 文件主要是在开发环境所要用到的配置，代码如下：</h4><pre><code>var webpack = require(&apos;webpack&apos;)
var merge = require(&apos;webpack-merge&apos;)
var HtmlwebpackPlugin = require(&apos;html-webpack-plugin&apos;)
var path = require(&apos;path&apos;)
var config = require(&apos;./webpack.config&apos;)
module.exports = merge(config, {
  // cheap-module-eval-source-map is faster for development
  devtool: &apos;#cheap-module-eval-source-map&apos;,
  plugins: [
    new webpack.HotModuleReplacementPlugin(),
    new webpack.NoEmitOnErrorsPlugin(),
    new HtmlwebpackPlugin({
    template: path.resolve(__dirname, &apos;../index.html&apos;),
    inject: true
    }),
  ]
})
</code></pre><p>这里必须用到 <code>new webpack.HotModuleReplacementPlugin()</code> ，不然无法启用热更新<br>主要把仅在开发过程用到的配置写在这里，然后合并<code>webpack.base.conf.js</code>的参数</p>
<h4 id="webpack-base-conf-js-的配置如下："><a href="#webpack-base-conf-js-的配置如下：" class="headerlink" title="webpack.base.conf.js 的配置如下："></a><code>webpack.base.conf.js</code> 的配置如下：</h4><pre><code>var path = require(&apos;path&apos;)
module.exports = {
  devtool: &apos;eval-source-map&apos;,
  entry: {
    index: &apos;./src/index.js&apos;
  },
  output: {
    path: __dirname + &apos;/dist&apos;,
    filename: &apos;bundle.js&apos;,
    publicPath: &apos;/&apos;
  },
  resolve: {
    extensions: [&apos;.js&apos;, &apos;.jsx&apos;],
    alias: {
      &apos;src&apos;: path.resolve(__dirname, &apos;/src&apos;)
    }
  },
  module: {
    loaders: [
    {
      test: /\.jsx?$/,
      loader: &apos;babel-loader&apos;,
      exclude: path.resolve(__dirname, &apos;/node_modules&apos;)
    }
    ]
  }
}
</code></pre><p>这里只留下entry，resolve，output三个属性</p>
<h4 id="在-webpack-dev-conf-js-中添加这么一段代码，将-webpack-hot-middleware-注入到entry里面去"><a href="#在-webpack-dev-conf-js-中添加这么一段代码，将-webpack-hot-middleware-注入到entry里面去" class="headerlink" title="在 webpack.dev.conf.js 中添加这么一段代码，将 webpack-hot-middleware 注入到entry里面去"></a>在 <code>webpack.dev.conf.js</code> 中添加这么一段代码，将 <code>webpack-hot-middleware</code> 注入到entry里面去</h4><pre><code>Object.keys(config.entry).forEach(function (name) {
  config.entry[name] = [&apos;webpack-hot-middleware/client&apos;].concat(config.entry[name])
})
</code></pre><p>当然你也可以直接在 <code>webpack.base.conf.js</code> 中的entry里面这样写：</p>
<pre><code>entry: [
    webpack-hot-middleware/client,
    &apos;./src/index.js&apos;
]
</code></pre><p>但是为了开发和生产环境分离，我们还是推荐选择第一种写法，<font color="red">注意第一种写法entry是对象，而第二种写法则是数组</font></p>
<h2 id="创建dev-server-js文件，开启服务"><a href="#创建dev-server-js文件，开启服务" class="headerlink" title="创建dev-server.js文件，开启服务"></a>创建dev-server.js文件，开启服务</h2><p>在 build 文件夹下面创建 <code>dev-server.js</code><br>代码如下：</p>
<pre><code>var path = require(&apos;path&apos;)
var express = require(&apos;express&apos;)
var webpack = require(&apos;webpack&apos;)
var config = require(&apos;./webpack.dev.conf&apos;)
var app = express()
var compiler = webpack(config)
app.use(require(&apos;webpack-dev-middleware&apos;)(compiler, {
  noInfo: true,
  publicPath: config.output.publicPath
}))
app.use(require(&apos;webpack-hot-middleware&apos;)(compiler))
app.listen(3000, function(err) {
  if (err) {
    console.log(err)
    return
  }
  console.log(&apos;Listening at http://localhost:3000&apos;)
})
</code></pre><p>这个文件引进 <code>webpack.base.conf.js</code> 的配置，用express开启了一个服务器，监听端口3000</p>
<p>修改script中的配置：</p>
<pre><code>&quot;scripts&quot;: {
 &quot;dev&quot;: &quot;node build/dev-server.js&quot;
}
</code></pre><p>然后命令行输入： npm run dev<br>等待几秒，你就会发现我们的页面正常显示了！</p>
<h3 id="热刷新"><a href="#热刷新" class="headerlink" title="热刷新"></a>热刷新</h3><p>问题来了，当你修改index.js 里面的值的时候，你会发现页面根本没有自动刷新，而且控制台输出了这样一段信息</p>
<blockquote>
<p>following modules couldn’t be hot updated: (Full reload needed)<br>This is usually because the modules which have changed (and their parents) do not know how to hot reload themselves.</p>
</blockquote>
<p>这是因为我们仅仅是运用了 <code>webpack-dev-middleware</code> 和 <code>webpack-hot-middleware</code><br>一开始说过的 <code>babel-plugin-react-transform</code> 这三个包还没有用上<br>怎么用呢？我们可以直接在 <code>.babelrc</code> 中添加：</p>
<pre><code>{
  &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;],
  &quot;env&quot;: {
   &quot;development&quot;: {
     &quot;presets&quot;: [&quot;react-hmre&quot;]
   }
  }
}
</code></pre><p>这样子就行了，然后重启一次服务，这样子就可以实现热刷新了！</p>
<h3 id="8月12日更新"><a href="#8月12日更新" class="headerlink" title="8月12日更新"></a>8月12日更新</h3><p>对于文件入口，要加入以下代码: </p>
<pre><code>if(module.hot)
 {
     module.hot.accept();
 }
</code></pre><p>不然对于主入口的数据无法进行热更新，当更改主入口数据时候会报错</p>
<blockquote>
<p>following modules couldn’t be hot updated: (Full reload needed)<br>This is usually because the modules which have changed (and their parents) do not know how to hot reload themselves.</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/10/从零开始学习react第一天/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yezi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/从零开始学习react第一天/" itemprop="url">从零开始学习react第一天</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T01:17:17+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/10/从零开始学习react第一天/" class="leancloud_visitors" data-flag-title="从零开始学习react第一天">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从零开始学习react第一天"><a href="#从零开始学习react第一天" class="headerlink" title="从零开始学习react第一天"></a>从零开始学习react第一天</h1><hr>
<h2 id="从零开始学习react，我会详细地解析每一步的意义，希望能够对大家学习react有所帮助"><a href="#从零开始学习react，我会详细地解析每一步的意义，希望能够对大家学习react有所帮助" class="headerlink" title="从零开始学习react，我会详细地解析每一步的意义，希望能够对大家学习react有所帮助"></a>从零开始学习react，我会详细地解析每一步的意义，希望能够对大家学习react有所帮助</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="sect-安装配置"><a href="#sect-安装配置" class="headerlink" title="&sect; 安装配置"></a>&sect; <a href="#dev">安装配置</a></h3><h3 id="sect-运行一个简单的react页面"><a href="#sect-运行一个简单的react页面" class="headerlink" title="&sect; 运行一个简单的react页面"></a>&sect; <a href="#simplePage">运行一个简单的react页面</a></h3><h3 id="sect-自动刷新"><a href="#sect-自动刷新" class="headerlink" title="&sect; 自动刷新"></a>&sect; <a href="#refresh">自动刷新</a></h3><h2 id="1-安装配置"><a href="#1-安装配置" class="headerlink" title="1. 安装配置"></a><a name="dev">1. 安装配置</a></h2><h3 id="第一步：Node-js"><a href="#第一步：Node-js" class="headerlink" title="第一步：Node.js"></a>第一步：Node.js</h3><p>首先需要到 <a href="http://nodejs.org/" target="_blank" rel="external">http://nodejs.org/</a> 下载安装最新版本的 Node.js<br>我使用的版本是 node 8+ </p>
<h3 id="第二步：新建空前端项目"><a href="#第二步：新建空前端项目" class="headerlink" title="第二步：新建空前端项目"></a>第二步：新建空前端项目</h3><p>在你新建的文件夹根目录下，进入命令行，输入</p>
<blockquote>
<p>npm init</p>
</blockquote>
<p>然后一路 <code>enter</code> 就行<br>在根目录下创建 <code>index.html</code></p>
<pre><code>&lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot;&gt;
      &lt;title&gt;react-demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>在根目录下创建 <code>src</code> 文件夹，同时在里面创建 <code>index.js</code> 文件，这是我们项目的入口</p>
<p>整个项目结构如下：<br>├── package.json      // 项目配置信息<br>├── index.html      // 入口 HTML<br>├── dist            // dist 目录放置编译过后的文件文件<br>└── src             // src 目录放置源文件<br>    └── index.js    // 入口 js </p>
<hr>
<h2 id="运行一个简单的react页面"><a href="#运行一个简单的react页面" class="headerlink" title="运行一个简单的react页面"></a><a name="simplePage">运行一个简单的react页面</a></h2><h3 id="第一步：-安装依赖"><a href="#第一步：-安装依赖" class="headerlink" title="第一步： 安装依赖"></a>第一步： 安装依赖</h3><p>要运行react页面，我们需要两个包 <code>react</code> <code>react-dom</code></p>
<blockquote>
<p>npm install react react-dom –save-dev</p>
</blockquote>
<h3 id="第二步：编写index-js文件"><a href="#第二步：编写index-js文件" class="headerlink" title="第二步：编写index.js文件"></a>第二步：编写index.js文件</h3><pre><code>var React = require(&apos;react&apos;)
var ReactDom = require(&apos;react-dom&apos;)
ReactDom.render(
  &lt;h1&gt;hello world&lt;/h1&gt;,
  document.getElementById(&apos;app&apos;)
)
</code></pre><p>在index.html中引用index.js</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;
</code></pre><p>当然，如果仅仅是这样，是完全不可能运行得了页面的，因为浏览器根本不支持jsx语法，这个时候我们就要用到webpack来打包我们的页面啦<br>备注：这次是主要达到webpack+ES6+react项目，所以在这里不用Browser.js来转换jsx语法啦</p>
<h3 id="第三步：配置webpack"><a href="#第三步：配置webpack" class="headerlink" title="第三步：配置webpack"></a>第三步：配置webpack</h3><blockquote>
<p>npm webpack –save-dev</p>
</blockquote>
<p>在根目录下创建webpack.config.js文件，详细代码如下</p>
<pre><code>var webpack = require(&apos;webpack&apos;)
// 这个plugin是用来将js注入html模板
var HtmlwebpackPlugin = require(&apos;html-webpack-plugin&apos;)
var path = require(&apos;path&apos;)

module.exports = {
  devtool: &apos;eval-source-map&apos;,
  /*
   *入口文件的设置
   *支持三种形式 对象， 字符串， 数组
   *同时支持多个入口
   */
  entry: {
    app: &apos;./src/index.js&apos;
  },
  // 输出设置
  output: {
    path: __dirname + &apos;/dist&apos;,
    filename: &apos;bundle.js&apos;,
    publicPath: &apos;/dist&apos;
  },
  resolve: {
    // 打包后缀为wxtensions的文件
    extensions: [&apos;.js&apos;, &apos;.jsx&apos;],
    // 这个是路径的简写 src == ./src
    alias: {
      &apos;src&apos;: path.resolve(__dirname, &apos;/src&apos;)
    }
  },
  plugins: [
    new HtmlwebpackPlugin({
     template: path.resolve(__dirname, &apos;./index.html&apos;),
     // 把入口文件注入到html的body之前
     inject: true
    })
  ]
}
</code></pre><p>这样子我们就设置了项目的入口和出口,还有模板html，<font color="blue">我们还需要对jsx语法进行转换，才可以达到页面的展示</font></p>
<h3 id="第四步：运用babel转换jsx"><a href="#第四步：运用babel转换jsx" class="headerlink" title="第四步：运用babel转换jsx"></a>第四步：运用babel转换jsx</h3><p>首先我们需要下载依赖</p>
<blockquote>
<p> npm install  babel-core babel-loader babel-preset-es2015 babel-preset-react –save-dev</p>
</blockquote>
<p><code>babel-preset-es2015</code> <code>babel-preset-react</code> 是babel的预处理模块</p>
<p>在package.config.js中增加一个对象：</p>
<pre><code>module: {
    loaders: [
      {
        test: /\.jsx?$/,
        loader: &apos;babel-loader&apos;,
        // exclude不转换指定目录， include转换
        exclude: path.resolve(__dirname, &apos;/node_modules&apos;),
        query: {
            presets: [&apos;es2005&apos;, &apos;react&apos;]
        }
      }
    ]
}
</code></pre><p>这样子就可以将ES6 + jsx转化为ES5 + js了<br>当然还有个更优雅的写法，把 <code>query</code> 去掉，在项目根目录下新建 <code>.babelrc</code> 文件，在里面写上：</p>
<pre><code>{
&quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;]
}
</code></pre><p>达到的效果是一样的，你甚至还可以在 <code>.babelrc</code> 里面设置更多的属性</p>
<h3 id="第五步：打包项目，运行页面"><a href="#第五步：打包项目，运行页面" class="headerlink" title="第五步：打包项目，运行页面"></a>第五步：打包项目，运行页面</h3><p>做到这一步已经离成功不远了，我们在根目录下进入命令行，输入：</p>
<blockquote>
<p>webpack</p>
</blockquote>
<p>然后系统就开始打包啦！，我们只要等待打包结果出来就行<br><img src="http://wx1.sinaimg.cn/mw690/a359ab18gy1fidyk98xlmj20o309ut8y.jpg" alt="webpack"></p>
<p>可以看到在 <code>dist</code> 文件夹下多出来两个文件 <code>bundle.js</code> <code>index.html</code><br>我们打开 dist/index.html，可以看到我们的页面已经正常运行了<br><img src="http://wx3.sinaimg.cn/mw690/a359ab18gy1fidyn2eyedj20je07qjri.jpg" alt="index"></p>
<hr>
<h2 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a><a name="refresh">自动更新</a></h2><p>想象一个场景，你给app的背景修改边距，你每改一次代码都要用webpack打包一次，这样效率太低，也不利于调试和修改</p>
<p>这是我们可以用 <code>webpack-dev-server</code> 这个插件来实现热更新</p>
<h3 id="第一步-万年不变的安装依赖"><a href="#第一步-万年不变的安装依赖" class="headerlink" title="第一步:万年不变的安装依赖"></a>第一步:万年不变的安装依赖</h3><blockquote>
<p>npm install webpack-dev-server –save-dev</p>
</blockquote>
<p><code>webpack-dev-server</code> 是一个小型的Node.js Express服务器,它使用webpack-dev-middleware来服务于webpack的包,除此自外，它还有一个通过Sock.js来连接到服务器的微型运行时.</p>
<p>然后我们在 <code>pakage.json</code> 文件里面找到 <code>scripts</code> ,添加这样一段：</p>
<pre><code>&quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --inline&quot;
}
</code></pre><p>在pakage.json中加入这段代码：</p>
<pre><code>devServer: {
    inline: true,//实时刷新
    historyApiFallback: true
}
</code></pre><h4 id="踩坑，请注意了："><a href="#踩坑，请注意了：" class="headerlink" title="踩坑，请注意了："></a><font color="red">踩坑，请注意了：</font></h4><ol>
<li>pakage.json 要设置 <code>publicPath</code> : <code>/</code> 不然无法热更新</li>
<li>pakage.json 要在<code>plugins</code>设置一个新的插件 <code>new webpack.HotModuleReplacementPlugin()</code> 不然启动之后会无法显示出页面<br>其中：<blockquote>
<p><code>--inline</code> 启用inline模式 详细参数可以点击链接查看<a href="https://segmentfault.com/a/1190000006964335" target="_blank" rel="external">webpack-dev-server详解</a><br><code>--hot</code> 不要按网上教程加上  webpack 2+之后加了之后就无法热更新<br><code>colors</code> 这个也不要加，会报错</p>
</blockquote>
</li>
</ol>
<h3 id="第二步-启动"><a href="#第二步-启动" class="headerlink" title="第二步:启动"></a>第二步:启动</h3><blockquote>
<p>npm run dev<br>然后项目就会自动打包，同时我们打开 <code>http://localhost:8080</code></p>
</blockquote>
<p>就可以看到我们的页面，改动index.js的内容，你可以看到页面会自动刷新！<br>这样，我们今天所要讲的内容就全部到此结束啦</p>
<p>by the way， 听说 <code>webpack-dev-server</code> 已经停止维护了，改为使用 <code>react-transform</code><br>明天我再详细了解了解~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/ES6-promise原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yezi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/ES6-promise原理/" itemprop="url">ES6 promise原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T18:41:08+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/06/ES6-promise原理/" class="leancloud_visitors" data-flag-title="ES6 promise原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ES6-Promise原理"><a href="#ES6-Promise原理" class="headerlink" title="ES6 Promise原理"></a>ES6 Promise原理</h1><hr>
<p>最近在学爬虫，对继步的操作十分烦恼，因为需要用到异步函数。于是开始研究起异步编程，现在看到ES6的promise异步，觉得十分有趣，于是上网查了查它的原理。</p>
<p>参考： mengera88的文章<br>地址链接：<a href="https://segmentfault.com/a/1190000009478377" target="_blank" rel="external">mengera88的文章</a></p>
<h2 id="简单的Promise函数"><a href="#简单的Promise函数" class="headerlink" title="简单的Promise函数"></a>简单的Promise函数</h2><pre><code>function promise (fn) {
    // 定义状态，一共有三种 ‘pending’， ‘fulfilled’，‘rejected’ 
    var state = &apos;pending&apos;,
    // 定义回调组，因为可能存在多个函数
    callbacks = [],
    // 定义在resolve（value）传进去的值
    value = null
    this.then = function (onFulfilled) {
        // ...
    }
    function resolve (newValue) {
        // ...
    }
    fn(resolve)
  }
</code></pre><p>一个简单的promise框架已经搭设好，这里没有加入<font color="red">rejected</font>回调，这个以后再说</p>
<h3 id="测试promise用的函数"><a href="#测试promise用的函数" class="headerlink" title="测试promise用的函数"></a>测试promise用的函数</h3><p>现在我们再看看怎么调用promise</p>
<pre><code>function getUserId() {
    return new promise (function(resolve) {
      //模拟异步请求
      setTimeout(function () {
        resolve(&apos;success&apos;)
      }, 2000)
    })
  }
  // 主函数
  getUserId().then(function (value) {
    console.log(value)
  })
</code></pre><ol>
<li>调用then方法，将想要在Promise异步操作成功时执行的回调放入callbacks队列，其实也就是注册回调函数，可以向观察者模式方向思考；</li>
<li>创建Promise实例时传入的函数会被赋予一个函数类型的参数，即<font color="red">resolve</font>，它接收一个参数<font color="red">value</font>，代表异步操作返回的结果，当一步操作执行成功后，用户会调用resolve方法，这时候其实真正执行的操作是将callbacks队列中的回调一一执行。</li>
</ol>
<h3 id="改进promise-（完善then和resolve）"><a href="#改进promise-（完善then和resolve）" class="headerlink" title="改进promise  （完善then和resolve）"></a>改进promise  （完善then和resolve）</h3><pre><code>function promise (fn) {
    var state = &apos;pending&apos;,
    callbacks = [],
    value = null
    this.then = function (onFulfilled) {
      // 在等待时间保存传进来的函数 
      if (state === &apos;pending&apos;) {
        callbacks.push(onFulfilled)
        // return this 是为能链式调用then
        return this
      }
      // 保证在异步结束后，后续函数能正常执行
      onFulfilled(value)
      return this
    }
    // 防止resolve在then完成之前执行
    function resolve (newValue) {
      value = newValue
      state = &apos;fulfilled&apos;
      // 将resolve置于队列尾部，防止在then之前就执行
      setTimeout(function () {
        callbacks.forEach(function (callback) {
          callback(value)
        })
      }, 0)
    }
    fn(resolve)
  }
</code></pre><p>这个样子我们再运行上面测试promise的代码，结果就是异步调用成功</p>
<h2 id="链式promise"><a href="#链式promise" class="headerlink" title="链式promise"></a>链式promise</h2><p>上面的代码虽然可以实现异步，但却无法实现链式异步，就是连续两个promise。假设有这样一个场景：你get请求一个数据，然后之后的post方法依赖get过来的请求，这就需要到达链式异步</p>
<h3 id="测试用的代码"><a href="#测试用的代码" class="headerlink" title="测试用的代码"></a>测试用的代码</h3><pre><code>function fn1() {
    return new promise(function (resolve) {
      setTimeout(function () {
        console.log(&apos;fn1 is over&apos;)
        resolve(&apos;success&apos;)
      }, 3000)
    })
  }
  function fn2(val) {
    console.log(&apos;fn2 receipt:&apos;, val);
    return new promise(function (resolve) {
      setTimeout(function () {
        console.log(&apos;fn2 is over&apos;)
        resolve(&apos;fali&apos;)
      }, 5000)
    })
  }
  // 主函数
  fn1().then(fn2).then(function (val) {
    console.log(val)
  })
</code></pre><h3 id="1-对then方法修改"><a href="#1-对then方法修改" class="headerlink" title="1. 对then方法修改"></a>1. 对then方法修改</h3><pre><code>this.then = function (onFulfilled) {
      return new promise(function (resolve) {
        handle({
          onFulfilled: onFulfilled,
          resolve: resolve
        })
      })
    }
</code></pre><p>这是then返回一个promise对象，handle的数据保存在promise1中的callbacks</p>
<h3 id="2-对resolve修改"><a href="#2-对resolve修改" class="headerlink" title="2. 对resolve修改"></a>2. 对resolve修改</h3><pre><code>function resolve (newValue) {
    // 这是将fn2 return回的promise对象进行判断，如果是函数或者对象，就执行
    // 如果不太明白可以跳过，我下面会描述过程
      if (newValue &amp;&amp; (typeof newValue == &apos;object&apos; || typeof newValue === &apos;function&apos;)) {
        var then = newValue.then
        if (typeof then === &apos;function&apos;) {
          then.call(newValue, resolve)
          return
        }
      }
      value = newValue
      state = &apos;fulfilled&apos;
      // 将resolve置于队列尾部，防止在then之前就执行
      setTimeout(function () {
        callbacks.forEach(function (callback) {
          handle(callback)
        })
      }, 0)
    }
</code></pre><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><pre><code>window.onload = function () {
  function promise (fn) {
    var state = &apos;pending&apos;,
    callbacks = [],
    value = null
    this.then = function (onFulfilled) {
      return new promise(function (resolve) {
        handle({
          onFulfilled: onFulfilled,
          resolve: resolve
        })
      })
    }
    function handle (callback) {
      if (state === &apos;pending&apos;) {
        callbacks.push(callback)
        return
      } else if (state === &apos;fulfilled&apos;) {
        var ret = callback.onFulfilled(value) || value
        callback.resolve(ret)
      }
    }
    // 防止resolve在then完成之前执行
    function resolve (newValue) {
      if (newValue &amp;&amp; (typeof newValue == &apos;object&apos; || typeof newValue === &apos;function&apos;)) {
        var then = newValue.then
        if (typeof then === &apos;function&apos;) {
          then.call(newValue, resolve)
          return
        }
      }
      value = newValue
      state = &apos;fulfilled&apos;
      // 将resolve置于队列尾部，防止在then之前就执行
      setTimeout(function () {
        callbacks.forEach(function (callback) {
          handle(callback)
        })
      }, 0)
    }
    fn(resolve)
  }

  function fn1() {
    return new promise(function (resolve) {
      setTimeout(function () {
        console.log(&apos;fn1 is over&apos;)
        resolve(&apos;success&apos;)
      }, 3000)
    })
  }
  function fn2(val) {
    console.log(&apos;fn2 receipt:&apos;, val);
    return new promise(function (resolve) {
      setTimeout(function () {
        console.log(&apos;fn2 is over&apos;)
        resolve(&apos;fali&apos;)
      }, 5000)
    })
  }
  // 主函数
  fn1().then(fn2).then(function (val) {
    console.log(val)
  })
}
</code></pre><font color="red">函数执行过程：</font>

<ol>
<li>第一步执行<font color="blue">fn1函数</font>,创建promise1，这时因为计时器异步，所以直接执行then方法，把<font color="blue">fn2函数</font>添加到promise1的callbacks上，同时，因为then同时返回了一个promise2对象，所以<font color="blue">fn3函数</font>添加到promise2上</li>
<li>执行fn1计时器中的函数，然后执行promise1的resolve，传入’success’，因为传入的字符串，resolve执行handle(callback)，执行<font color="blue">if (state === ‘fulfilled’)里面的语句</font>。这个时候被执行的是<font color="blue">fn2函数</font></li>
<li>var ret = callback.onFulfilled(value) || value 执行后首先执行fn2里面的输出语句，然后将返回的promise3对象传给ret</li>
<li>执行resolve(ret)，就是走到resolve函数的if判断语句，<font color="red">then.call(newValue, resolve)结果等同于执行new promise4(resolve)</font></li>
<li>因为创建promise4,同理会先执行同步函数then，将fn3链接到promise4的callbacks，然后等promise4的计时器执行完毕，执行fn3</li>
<li>总的指向为： promise1 –&gt; fn2 &amp;&amp;  fn2 return的promise4 –&gt; fn3</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>是不是觉得很绕？ 绕就对了。。。。慢慢看多几次写几个console.log就会慢慢慢慢慢慢慢慢理解。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/31/js继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yezi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/31/js继承/" itemprop="url">js继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-31T16:22:50+08:00">
                2017-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/07/31/js继承/" class="leancloud_visitors" data-flag-title="js继承">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js继承"><a href="#js继承" class="headerlink" title="js继承"></a>js继承</h1><hr>
<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><h3 id="基于类继承的步骤："><a href="#基于类继承的步骤：" class="headerlink" title="基于类继承的步骤："></a>基于类继承的步骤：</h3><ol>
<li>用一个类的声明定义对象的结构</li>
<li>实例化该类以创建一个新对象，每个创建的对象都有一套该类的所有实例属性的副本</li>
</ol>
<h3 id="类继承与工厂模式的对比："><a href="#类继承与工厂模式的对比：" class="headerlink" title="类继承与工厂模式的对比："></a>类继承与<a href="https://yezi12138.github.io/2017/05/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FVS%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" target="_blank" rel="external">工厂模式</a>的对比：</h3><font color="red">工厂模式未能解决对象的类型，即由哪个构造函数创建的</font>

<h3 id="类继承的例子："><a href="#类继承的例子：" class="headerlink" title="类继承的例子："></a>类继承的例子：</h3><pre><code>// 创建父类
var Person = function (name) {
    this.name = name
  }
  Person.prototype.getName = function () {
    return this.name
  }
// 创建子类
var Author = function (name, book) {
    Person.call(this, name)
    this.book = book
  }
  // 子类继承父类
  Author.prototype = new Person()
  Author.prototype.construtor = Author
  // 子类的公共方法只能放在继承后面

  // 这是改进方法
  // extend(Author, Person)

  Author.prototype.getBook = function () {
    return this.book
  }
  var yezi = new Author(&apos;yezi&apos;, &apos;陪你度过漫长岁月&apos;)
  console.log(yezi.getName()) // yezi
  console.log(yezi.getBook()) // 陪你度过漫长岁月
</code></pre><h3 id="改进代码："><a href="#改进代码：" class="headerlink" title="改进代码："></a>改进代码：</h3><pre><code>// 定义继承方法
// 利用空函数作为中转，因为空函数几乎不占内存，而且可以避免构造函数的副作用
// 主要是new操作符会执行一遍父类函数，如果父类函数过大，则耗费大
  function extend (subClass, superClass) {
    var F = function () {}
    F.prototype = superClass.prototype
    subClass.prototype = new F()
    subClass.prototype.construtor = subClass
  }
</code></pre><h3 id="类继承的对象bug"><a href="#类继承的对象bug" class="headerlink" title="类继承的对象bug"></a>类继承的对象bug</h3><pre><code>// 重新定义父类
var Person = function (name) {
    this.name = name
    this.behavior = {
      foot: true,
      eat: true
    }
  }
// 其他代码同上
// 创建两个实例
var yezi = new Author(&apos;yezi&apos;, &apos;陪你度过漫长岁月&apos;)
var feifei = new Author(&apos;feifei&apos;, &apos;岁月如歌&apos;)
yezi.behavior = {
    foot: false,
    eat: false
}
console.log(yezi.behavior) // Object {foot: false, eat: false}
console.log(feifei.behavior) // Object {foot: true, eat: true}
</code></pre><font color="red">总结：</font> 直接改变继承的对象值，相当于给实例添加新的属性behavior<br><br>接下来看看另外一个改变对象测试<br><br>    yezi.behavior.foot = false<br>    yezi.behavior.eat = false<br>    console.log(yezi.behavior) // Object {foot: false, eat: false}<br>    console.log(feifei.behavior) // Object {foot: true, eat: true}<br><br><font color="red">总结：</font> 通过这种方式，原理是实例会向上查找behavior属性，再找到foot和eat的值进行修改，而不是给实例直接添加新的behavior属性，这可以说是一个bug.<br><br>—<br><br><br>## 原型链继承<br><br>### 原型链继承区别之前提到的类继承，类继承沿用的是java面向对象的思维，而原型链则是利用js设计的思维<br><font color="blue">相对于类继承，原型链继承更加简单，但是依然避免不了引用类型的共享bug，原型链继承我理解为是浅复制，对于简单类型进行复制副本，引用类型则用‘指针’指向</font>

<h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计:"></a>代码设计:</h3><pre><code>// 原型链继承的主要函数
function clone (object) {
    var fn = function () {}
    fn.prototype = object
    return new fn()
}
</code></pre><p>测试代码：</p>
<pre><code>var person = {
    name: &apos;default name&apos;,
    behavior: {
      foot: true,
      eat: true
    },
    hands: [1, 2, 3, 4, 5]
  }

  var author1 = clone(person)
  var author2 = clone(person)
  author1.name = &apos;yezi&apos;
  author2.name = &apos;feifei&apos;
  console.log(&apos;author1.name=&apos;, author1.name)
  console.log(&apos;author1.behavior=&apos;, author1.behavior)
  author2.behavior = {
    foot: false,
      eat: false
  }
  author2.hands.push(5)
  console.log(&apos;author1 hasownpropety&apos;, author1.hasOwnProperty(&apos;behavior&apos;))
  console.log(&apos;author2 hasownpropety&apos;, author2.hasOwnProperty(&apos;behavior&apos;))
  console.log(&apos;author2.name=&apos;, author2.name)
  console.log(&apos;author2.behavior=&apos;, author2.behavior)
  console.log(&apos;author1.hands=&apos;, author1.hands)
  console.log(&apos;author2.hands=&apos;, author2.hands)
</code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p><img src="http://wx4.sinaimg.cn/mw690/a359ab18gy1fi354qbexwj207y06r0st.jpg" alt="此处输入图片的描述"></p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ol>
<li>利用 obj.hasOwnProperty(prop) 可以看出，将author2.behavior的值改变，<font color="red">相当于给author2添加新的behavior属性，而author1自身不存在behavior属性</font>，author1通过原型链向上查找父类的behavior属性</li>
<li>同时author1.hands的改变影响了author2.hands的值，所以这是一个浅复制</li>
</ol>
<hr>
<h2 id="new操作符的实现步骤"><a href="#new操作符的实现步骤" class="headerlink" title="new操作符的实现步骤"></a>new操作符的实现步骤</h2><p>new共经历四个过程</p>
<pre><code>var fn = function () {}
var fnObj = new fn()
</code></pre><ol>
<li><p>创建一个空对象</p>
<p>  var obj = new object()</p>
</li>
<li><p>设置原型链</p>
<p> obj.<em>proto</em> = fn.prototype</p>
</li>
<li><p>让fn的this指向obj，并执行fn的函数体</p>
<p> var result = fn.call(obj)</p>
</li>
<li><p>判断fn的返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象</p>
<p> if (typeof(result) === ‘object’) {<br>   fnObj = result<br> } else {<br>   fnObj = obj<br> }</p>
</li>
</ol>
<hr>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>JavaScript设计模式 （2009年+(美国)(Rossharmes)哈梅斯(美国)(DustinDiaz)迪亚斯+《JavaScript设计模式》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="yezi" />
          <p class="site-author-name" itemprop="name">yezi</p>
           
              <p class="site-description motion-element" itemprop="description">personal develop</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yezi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>
<div>
  <span id="busuanzi_container_site_uv">
  total visited  <span id="busuanzi_value_site_uv" class="theme-link"></span>  times
</span>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("rDSYKuVWnEhpcTVUFtDO19kY-gzGzoHsz", "xUOAx49gXbPVpMgp3dtpl9La");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
